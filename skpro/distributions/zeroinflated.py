"""Zero-Inflated distribution implementation."""

import numpy as np
from numpy.typing import ArrayLike

from skpro.distributions.base import BaseDistribution
from skpro.distributions.truncated import TruncatedDistribution


class ZeroInflated(BaseDistribution):
    r"""A Zero-Inflated distribution.

    Combines a Bernoulli gate for structural zeros with a with a base distribution
    defined on non-negative values, allowing zeros to arise from both components.
    Mathematically this can be expressed as:

    .. math::
        Y_t = \begin{cases}
                0 &\text{ with probability } 1 - \pi, \\
                X \sim f(x \mid x \ge 0) &\text{ with probability } \pi,
        \end{cases}
    where :math:`\pi` is the probability of the outcome being generated by the
    count distribution.
    :math:`f(x \mid x \ge 0)` is the probability mass function of the base
    distribution defined on non-negative values.

    Parameters
    ----------
    p : ArrayLike
        The probability of the outcome being generated by the base distribution.

    distribution : BaseDistribution
        Arbitrary distribution.

    Examples
    --------
    >>> from skpro.distributions import Poisson, ZeroInflated
    >>>
    >>> base = Poisson(mu=2.0)
    >>> zi = ZeroInflated(p=0.7, distribution=base)
    >>> samples = zi.sample(1000)
    """

    _tags = {
        "capabilities:approx": ["energy"],
        "capabilities:exact": ["ppf", "mean", "var", "log_pmf", "pmf", "cdf"],
        "distr:measuretype": "mixed",
        "distr:paramtype": "parametric",
        "broadcast_init": "on",
    }

    def __init__(
        self,
        p: ArrayLike,
        distribution: BaseDistribution,
        index=None,
        columns=None,
    ):
        if isinstance(p, np.ndarray) and p.ndim == 1:
            raise ValueError("p must be a scalar or a 2D array.")
        elif isinstance(p, np.ndarray) and p.ndim == 2:
            assert (
                p.shape[0] == distribution.shape[0]
            ), "If p is a 2D array, it must match the shape of the distribution."

        self.p = p
        self.distribution = distribution

        super().__init__(
            index=index if index is not None else distribution.index,
            columns=columns if columns is not None else distribution.columns,
        )

        # the capabilities of this (self) distribution are exact
        # if and only if the capabilities of the inner distribution are exact
        self_exact_capas = self.get_tag("capabilities:exact", []).copy()
        self_approx_capas = self.get_tag("capabilities:approx", []).copy()
        distr_exact_capas = distribution.get_tag("capabilities:exact", []).copy()
        for capa in self_exact_capas:
            if capa not in distr_exact_capas:
                self_exact_capas.remove(capa)
                self_approx_capas.append(capa)

        self.set_tags(**{"capabilities:exact": self_exact_capas})
        self.set_tags(**{"capabilities:approx": self_approx_capas})

        # the measuretype of this distribution is discrete if the inner
        # distribution is discrete, otherwise it is mixed
        inner_measuretype = distribution.get_tag("distr:measuretype", "mixed")
        if inner_measuretype == "discrete":
            self.set_tags(**{"distr:measuretype": "discrete"})

        inner_paramtype = distribution.get_tag("distr:paramtype", "parametric")
        if inner_paramtype != "parametric":
            self.set_tags(**{"distr:paramtype": inner_paramtype})

    @property
    def _truncated_distribution(self) -> TruncatedDistribution:
        return TruncatedDistribution(
            self.distribution,
            lower=0.0,
            inclusive_lower=True,
            index=self.index,
            columns=self.columns,
        )

    def _log_pmf(self, x):
        log_prob_base_zero = self._truncated_distribution.log_pmf(np.zeros_like(x))
        prob_base_at_zero = np.exp(log_prob_base_zero)

        # P(X=0) = (1 - p) + p * f(0)
        prob_zero_total = (1.0 - self.p) + (self.p * prob_base_at_zero)
        log_prob_total_zero = np.log(prob_zero_total)

        # P(X=x) = p * f(x)
        log_prob_active = np.log(self.p)
        log_prob_base = self._truncated_distribution.log_pmf(x)
        log_prob_non_zero = log_prob_active + log_prob_base

        is_zero = x == 0
        return np.where(is_zero, log_prob_total_zero, log_prob_non_zero)

    def _pmf(self, x):
        prob_weighted_base = self.p * self._truncated_distribution.pmf(x)
        prob_structural_zero = 1.0 - self.p

        # Returns: (1-p) + p*f(0) if x==0, else p*f(x)
        return np.where(
            x == 0, prob_weighted_base + prob_structural_zero, prob_weighted_base
        )

    def _log_pdf(self, x):
        log_prob_structural_zero = np.log(1.0 - self.p)

        log_prob_active = np.log(self.p)
        log_prob_base = self._truncated_distribution.log_pdf(x)
        log_prob_non_zero = log_prob_active + log_prob_base

        is_zero = x == 0
        return np.where(is_zero, log_prob_structural_zero, log_prob_non_zero)

    def _pdf(self, x):
        prob_structural_zero = 1.0 - self.p
        prob_active = self.p
        prob_non_zero = prob_active * self._truncated_distribution.pdf(x)

        is_zero = x == 0
        return np.where(is_zero, prob_structural_zero, prob_non_zero)

    def _mean(self):
        return self.p * self._truncated_distribution.mean()

    def _var(self):
        mean_base = self._truncated_distribution.mean()
        var_base = self._truncated_distribution.var()

        expected_sq_base = var_base + mean_base**2

        expected_sq_total = self.p * expected_sq_base
        mean_total_sq = (self.p * mean_base) ** 2

        return expected_sq_total - mean_total_sq

    def _ppf(self, p):
        prob_structural_zero = 1.0 - self.p

        q_rescaled = (p - prob_structural_zero) / self.p
        q_rescaled = np.clip(q_rescaled, 0.0, 1.0)

        y_base = self._truncated_distribution.ppf(q_rescaled)

        return np.where(p <= prob_structural_zero, 0.0, y_base)

    def _cdf(self, x):
        is_non_negative = x >= 0.0
        prob_non_negative = self._truncated_distribution.cdf(x)

        return np.where(
            is_non_negative, (1.0 - self.p) + self.p * prob_non_negative, 0.0
        )

    @classmethod
    def get_test_params(cls, parameter_set="default"):
        """Return testing parameter settings for the estimator."""
        import numpy as np
        import pandas as pd

        from skpro.distributions import Poisson

        # scalar
        params_1 = {
            "p": 0.4,
            "distribution": Poisson(mu=1.0),
        }

        # array 1
        mu = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
        idx = pd.Index([0, 1])
        cols = pd.Index(["a", "b", "c"])

        poisson_dist = Poisson(mu=mu, columns=cols, index=idx)

        params_2 = {
            "p": 0.3,
            "distribution": poisson_dist,
            "index": idx,
            "columns": cols,
        }

        # array 2
        params_3 = {
            "p": np.array([0.2, 0.3]).reshape(-1, 1),
            "distribution": poisson_dist,
            "index": idx,
            "columns": cols,
        }

        params = [params_1, params_2, params_3]

        # continous
        from skpro.distributions import Normal

        params_continuous_1 = {
            "p": 0.3,
            "distribution": Normal(mu=1.0, sigma=1.0),
        }

        params_continuous_2 = {
            "p": 0.3,
            "distribution": Normal(mu=mu, sigma=1.0, columns=cols, index=idx),
            "index": idx,
            "columns": cols,
        }

        return params + [params_continuous_1, params_continuous_2]

    # TODO: Replace with default behavior after PR #644 is merged.
    def _iloc(self, rowidx=None, colidx=None):
        distr = self.distribution.iloc[rowidx, colidx]
        p = self.p

        if rowidx is not None:
            new_index = self.index[rowidx]

            if isinstance(self.p, np.ndarray) and self.p.ndim > 0:
                p = p[rowidx]
        else:
            new_index = self.index

        if colidx is not None:
            new_columns = self.columns[colidx]

            if isinstance(self.p, np.ndarray) and self.p.shape[-1] > 1:
                p = p[:, colidx]
        else:
            new_columns = self.columns

        cls = type(self)
        return cls(
            p=p,
            distribution=distr,
            index=new_index,
            columns=new_columns,
        )

    def _iat(self, rowidx=None, colidx=None):
        if rowidx is None or colidx is None:
            raise ValueError("iat method requires both row and column index")

        subset_p = self._subset_param(
            val=self.p,
            rowidx=rowidx,
            colidx=colidx,
            coerce_scalar=True,
        )

        self_subset = self.iloc[[rowidx], [colidx]]
        return type(self)(distribution=self_subset.distribution.iat[0, 0], p=subset_p)
